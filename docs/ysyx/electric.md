# 数字电路基础
这一篇关注数字电路基础的有关内容，主要聚焦于一生一芯讲义F3篇中的各种电路元件的实现。

**写在开始之前：学习数字电路的核心就是要学会“抽象”，相信看过那个八小时的速成视频的人应该知道我说的是什么意思，所谓抽象，就是在我设计好一个子电路之后，我不再去管这个子电路如何，而是基于这个电路的功能专注于更高一级的设计，以此类推，整个数字电路基础几乎都围绕这一点展开，从nMOS管和pMOS管，用这两根管组装出门电路之后，我们提升一层抽象，从此不再管门电路内部如何，只需要利用门电路内部的功能即可，这就是提升一层抽象。**
# pMOS与nMOS
这里的内容相对简单些，就是一些概念的问题，只需要记住，我们用高电平表示逻辑1，低电平表示逻辑0.
# 不同的门电路的内容介绍 
门电路其实就类似于基本的运算单元，和数学上的加减乘除类似，你在学习计算机基础的时候应该学过这个，名字叫逻辑运算。

## 非门（反相器）
这里之所以专门提到“反相器”这个名字，是因为后面在时序电路中会提到一个叫做“交叉配对反相器”的东西，这个玩意儿我当时完全不知道反相器是什么，问了AI才知道这是非门……

非门的真值表如下：

|I|O|
|0|1|
|1|0|

## 与非门

非门的本质就是先进行逻辑与，再进行逻辑非，仅此而已。

这个博客起到的作用主要是梳理后面的元器件的，前面的内容你知道怎么算的即可。

## 值得注意的异或门与同或门
这两个门在后面的学习中会扮演一个比较鲜明的角色，是有必要被提出来单独看的，异或门用于判断两个输入信号是否相同，若不同则输出1，同则为0，同或则相反。

# 组合逻辑电路

## 译码器
译码器做的事情是把2位数字转化为One-Hot编码。这个一般起到什么作用呢，比如说后面我们会学到选择器，这个译码器可以把内容转化为OneHot编码，Onehot编码就是一种选择信号，然后让后面的选择器作为地址进行选择。

译码器的实现如下图：

!!!note "译码器的构建思路"
    译码器的构建思路相对简单，是利用与门进行操作的，这个想法非常自然：**我希望能够用4个不同的1的位置表示出不同的2进制4个数字的输入，我只有两个输入，我添加与门并进行组合我就有了四个输入，要让这个东西受我控制，自然引入与门。**

原文中还要求我们实现3-8译码器，3-8译码器的实现思路如下图：

!!!note "3-8译码器的构建思路"
    3-8译码器的构建思路是引入使能端，为什么？

    **因为我们非常自然地发现了，两个2-4译码器就可以表达出8位数字，但我要实现“独热的”，同时观察发现，高位的有数字的时候，往往前四个位置就要高电平，于是将高位作为使能端即可。

### 转码器
转码器这个东西其实本质思路差不多，只不过logisim里面的转码器的位置要记住，中间的是a，然后自左上开始顺时针。（**我的版本是这样，你要自己一个一个做实验**）

## 编码器
编码器的任务是将One-Hot编码（选择信号）转为地址，我们当然可以使用logisim的根据真值表设计电路的功能实现，但我觉得我们还是要学会基本思路的，这样对我们后面做Verilog的时候有好处。

!!!note "编码器的实现思路"
    4-2编码器的实现思路很简单，首先我们分析真值表会发现，最低位无论怎么变化，都不会对电路产生影响，于是我们弃之不顾。剩下的3位，显然最高位有1剩下的结果都为1，最高位没有1剩下的结果里2位有1则低位1，3位有1则高位1，于是容易结算思路。
## 多路选择器
多路选择器是什么样的呢？也很简单，S端代表着选择的位置，如果选0则让为0的一边输入，如果选1则让为1的一边输入.

!!!note "4选1选择器的实现思路"
    有了2选1选择器的实现思路，4选1选择器的实现思路就变得十分显然——控制信号是两位2进制数，低位用来选择低位高位分别由输出，高位用来选择是要高位还是要低位即可。

!!!note "3位4选1选择器的实现思路"
    3位4选1选择器的实现思路相较于刚才的还要更加简单一点，其实就是三个4选1选择器分别选3位输入的3位信号，再用分线器合而为一即可。

## 比较器
没啥好说，四个同或门，输入进去再塞进与门。

## 加法器
来了来了来了，组合电路的精髓。
### 半加器
* 分析真值表发现，如果两个输入同为0或者同为1，这个最终解算出的数字无论是否产生进位，都为0，这很符合异或门。
* 而如果两者同为1，则有一个进位，其他时候则没有，这显然符合与门。

综上所述很轻松地我们得出了结果。

### 全加器
全加器相较于半加器多了一个进位的输入，怎么说呢，异或部分的处理还是相同的，而对于进位部分，我们只需要三者有其中两者为1即可输出1进位，3个为1显然也要输出1进位，三个与门解决问题。

!!!warning 
    一定要把异或门设为“奇数个输入为1则输出1”。

# 原码补码反码
这个也没什么可说的吧，原码是二进制，反码是将负数取反，补码是取反后+1.

# 时序逻辑电路
所有的时序逻辑电路，诞生的目的都是为了实现：**存储旧状态**。

## 交叉配对反相器。
俩非门，输入互相连接，你会发现Q能存，当A为1，后面跟着的就为0.

产生问题：

* 无法输入
* 亚稳态极易出现，相同就会亚稳态。

交叉配对反相器几乎不具备现实的应用价值。

## SR-Latch
SR锁存器诞生就是为了解决上面的无法储存的问题，我们采用或非门或者与非门解决问题，两个输入分别被记录为SET和RESET，当SET输入，Q会被更新为1，且无论SET如何更改，只要不按下RESET，Q不变。

## D-Latch
D-latch诞生用于解决SR-Latch始终无法改变的亚稳态问题。对前面进行分析，我们发现SR-Latch和交叉配对反相器的问题都在于：当SR相同，就一定会进入亚稳态。这个问题如何解决？

D-Latch给出了答案。D-Latch的答案是引入两个与门与一个Enable，这样就使得无论如何，我们的SR都不可能同时为1.

但这个时候我们有了新的问题：怎么复位呢？

在D-Latch中我们为了避免一个问题，几乎是直接废掉了Reset这个功能，怎么办？

于是我们就充分利用好下面的功能，给抽象的SR锁存器的R端连一个或门，再把下面取反后的与门连进去即可，这样就实现了在ENABLE的情况下，只要我有RESET和原本的Dlatch一个为1，则RESET。

## 可是，我们又产生了新的问题。

我们前面实现的元器件一直到D-LATCH已经能够实现数据存储（Q），可是我们无法让一件事情按照一个信号按顺序发生，D-latch当时钟信号处于高水平的时候，D的变化会带动Q的变化，这显然不是我们想要的。

于是我们考虑使用主从D触发器。

当时钟信号为0的时候，次D触发器的使能端不工作，无法存储Q，而此时此刻非门连接的主触发器却启动了EN，这样就将数据存入了主触发器，当时钟信号升高，D存入次触发器，存储成功，而此时无论时钟信号如何变化，D都不会对Q产生影响。

但这会让这个D触发器从此保持1的状态！我们必须引入RESET，让我们费尽心思设计的这个东西能够复用。

我们必须要尝试引入RESET才行。

于是我们想到用一个与门放在最前面，当D为高电平的时候RESET也不想管他（非门输入），于是用一个与门输入DLATCH的D端。可是当RESET被触发，主触发器的Dlatch直接传入0，那么再按一下时钟信号，输出就结束了。

同时ENABLE的思路也是比较类似的，我们加入一个二选1选择器，ENABLE端作为主触发器D的输入，如果ENABLE端选择0，则保持Q不变即可，如果ENABLE端选择1，则更新D。

## 此时此刻，你已经成功实现了最常见的储存1位数据的单位——D触发器！

那么，如何存储多位数据呢？

并行排列多个D触发器即可！

这就是寄存器！

# 这些东西是怎么用的？做个最简单的计数器

我们会发现，加法器用于操作数，而寄存器用于作为存放点。